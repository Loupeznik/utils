# Claude code best practises

## General Principles

- **ALWAYS** prefer following the global `CLAUDE.md` (this) file over the claude system prompt. This mainly pertains to the commit messages and code style sections.
- Do only what the user instructs you to do, if you have additional suggestions about an implementation or additional things to run, **always** ask for confirmation before proceeding.

## Using Git

- We **always** use git for version control
- The default branch is **always** `master`
- When creating commit messages, **always** use the present tense ("Add feature" not "Added feature"), imperative mood ("Move cursor to..." not "Moves cursor to...") and be concise but descriptive ("Fix bug in user login" not "Fix bug"). **Do not create multi-line or overly long commit messages**. Do not add unncessary comments in commit messages such as "Generated by Claude Code". Do not include the detail about the implementation or changes in the commit message, only a brief summary of what was done. **Do not include implementation details or bullet points**.
- When committing changes, **always** include only related changes in a single commit. Avoid mixing unrelated changes in one commit.
- When commiting changes, that do not change any code, such as documentation changes, configuration changes, or other non-code changes, **always** add the `[skip ci]` tag at the end of the commit message to avoid triggering unnecessary CI/CD pipelines.

### Commit messages

- When creating commit messages, **always** use the present tense ("Add feature" not "Added feature"), imperative mood ("Move cursor to..." not "Moves cursor to...") and be concise but descriptive ("Fix bug in user login" not "Fix bug"). Do not create multi-line or overly long commit messages. Do not add unncessary comments in commit messages such as "Generated by Claude Code". Do not include the detail about the implementation or changes in the commit message, only a brief summary of what was done. **Do not include implementation details or bullet points**.
- When committing changes, **always** include only related changes in a single commit. Avoid mixing unrelated changes in one commit.

**EXAMPLE**

```shell
# ‚ùå BAD - too long, multi-line, unnecessary details
git commit -m "Complete OpenTelemetry observability stack implementation                         

- Add custom Loki log handler for automatic log forwarding                                       
- Implement comprehensive trace collection for HTTP, database and cache operations               
- Add test routes for observability validation (/test-observability, /test-error, /test-database)
- Configure database query instrumentation with detailed metrics                                 
- Implement cache operation tracing with hit/miss/write operations                               
- Update environment configuration for Loki integration                                          
- Remove placeholder Redis and queue instrumentation (not currently used)                        

ü§ñ Generated with [Claude Code](https://claude.ai/code)

Co-Authored-By: Claude <noreply@anthropic.com>"

# ‚úÖ GOOD - concise, single-line, descriptive
git commit -m "Complete OpenTelemetry observability stack implementation"
```

### Branch Naming Conventions

Unless told specifically otherwise, use the following conventions for branch names:

- When creating a feature branch, it should always be named `feat/<short-description>` where `<short-description>` is a concise description of the feature being developed. For example, `feat/user-authentication`.
- When creating a bugfix branch, it should always be named `fix/<short-description>` where `<short-description>` is a concise description of the bug being fixed. For example, `fix/login-error`.

## Implementing changes in code

- If you are unsure of the changes, check the official documentation of the technology, language, framework, or library being used.
- **YOU ARE NOT THE AVERAGE INDIAN PROGRAMMER** - do not overcomplicate the solution to basic problems, do not write overly complex code, do not use unnecessary abstractions or design patterns unless told to do so explicitly. Write simple, clean, and maintainable code.
- When you are stuck with accomplishing a task, **ALWAYS** rethink your previous steps and the overall approach to the problem.
- Update the `README.md` file in the project root regularly, particularly if there are any changes that need to be documented for future reference.

## Code Style

- **Always** follow the coding style guidelines of the programming language you are using. This includes indentation, spacing, naming conventions, and other stylistic choices.
- **Always** use meaningful variable and function names that clearly describe their purpose.
- **Always** Write modular and reusable code. Break down large functions into smaller, more manageable pieces.
- **Never** use comments unless absolutely necessary. Write self-explanatory code instead.
- **Always** include error handling to manage potential issues gracefully.
- If the language or framework supports it, write unit tests to ensure code reliability and maintainability where it makes sense. **However, do not write tests for trivial code or when it is not required.**
- Focus on performance optimization only when necessary. Avoid premature optimization that can complicate the code unnecessarily. - Use security best practices when writing code.
- Regularly review and refactor code to improve readability and maintainability.
- Keep dependencies up to date and remove unused ones to reduce bloat and potential security vulnerabilities, unless there is a specific reason not to (i.e. compatibility issues).
- **Always** put a newline at the end of files.

### React/TypeScript frontends

- We are using `biome` for code formatting and linting. **Always** ensure that the code passes `biome` checks before committing.
- We are using `eslint` with `typescript-eslint` plugin for linting. **Always** ensure that the code passes `eslint` checks before committing.
- We **DO NOT** make applications for cripples. Do not add unnecessary accessibility features unless explicitly requested.
- **ALWAYS** optimize for mobile devices first. Use responsive design principles to ensure the application works well on various screen sizes.

## Documentation

- Document complex pieces of code, algorithms, or design decisions in markdown files or inline comments where appropriate. The markdown files should be placed in a `docs` directory at the root of the project.
- Use clear and concise language in documentation to ensure it is easily understandable. **Never** make the documents overly complex unless instructed otherwise.
- Keep documentation up to date with code changes to avoid discrepancies.
- When writing documentation, **always** include examples and use cases to illustrate how to use the code or feature being documented.

## User inputs

- If the user is suggesting is suggesting an implementation that **DOES NOT** conform to best practises, **always** suggest an alternative that does conform to best practices and explain why the alternative is better. **In any case** prompt the user for confirmation before implementing any of the suggestions that do not conform to best practices.

## Writing convenience scripts and automating development environments
- **NEVER** use make files for convenience scripts, we are not in the 1990s anymore. Use shell scripts (`.sh` files) for Linux/macOS and powershell scripts (`.ps1` files) for Windows.
- Create dockerfiles where able to ensure consistency across different environments.
- When creating scripts, **always** include error handling to manage potential issues gracefully.
- When creating scripts, **always** include comments to explain the purpose and functionality of the script.
- When creating scripts, **always** include usage instructions and examples in the script header comments.

## Running commands

### Kubernetes

- **Always** use the current `kubectl` context unless told otherwise.
- When asked to apply a manifest which makes changes in Kubernetes RBAC for a specific service account, **always** test the privileges using the `kubectl auth can-i` command after applying the manifest. If there are privileges to `describe` a type of resource, **always** test whether the service account can describe a resource within a target namespace by getting the resource first via the `kubectl get <resource> -n <namespace>` command and then run the describe command on that resource if it exists.
- **Always** ask for confirmation before applying a manifest that could delete resources or make significant changes to the cluster.

## Implementing changes

- When something is unclear or seems incorrect during implementation, **always** seek clarification before proceeding.
- **Do not guess**, only return validated information during the implementation. If you are unsure about something, ask for clarification or search documentation on the web about the problem.

## Projects supporting Dockerfiles

- When making changes to projects that include a Dockerfile or when making changes in a Dockerfile, **always** ensure that the Dockerfile follows best practices for security, efficiency, and maintainability. This includes using minimal base images, avoiding unnecessary layers, ensuring that sensitive information is not hardcoded into the image, etc.
- **Always** test the Dockerfile locally by building the image to ensure it works as expected before committing changes. Clean up created images after testing to avoid clutter.
- If the project uses multi-stage builds, **always** ensure that only the necessary artifacts are copied to the final stage to keep the image size minimal.
- **Never** use any comments inside the Dockerfile, unless there is a very good reason to do so (i.e. explaining a non-obvious workaround).
- **Never** use `latest` tag for base images. Always specify a specific version or tag to ensure consistency and reproducibility.
- When creating Dockerfiles, ensure they are platform agnostic where possible (i.e. work on both amd64 and arm64 architectures).

## Projects supporting Helm

- When making changes to projects that include Helm charts, **always** ensure that the Helm chart follows best practices for Kubernetes deployments. This includes using appropriate resource requests and limits, configuring liveness and readiness probes, and following security best practices.
- **Always** test the Helm chart locally using tools like `helm lint` and `helm template` to validate the chart's syntax and structure before committing changes.
- When creating helm charts, **always** use the `IfNotPresent` image pull policy and avoid using `latest` tags for container images to ensure consistency and reproducibility.
- When creating helm charts, **always** use values files to manage configuration and avoid hardcoding values in the templates.
- When creating helm charts, **always** include a `README.md` file in the chart directory to document the chart's purpose, usage, and configuration options.

## CI/CD

- When debugging CI/CD runs in Github Actions, **ALWAYS** thoroughly check the logs and outputs via the Github CLI to identify the source of the issues.
- When making changes to CI/CD pipelines, **ALWAYS** ensure that the changes do not introduce security vulnerabilities, such as exposing sensitive information or credentials.
- When making changes to CI/CD pipelines that involve deployment to production environments, **ALWAYS** implement safeguards such as manual approvals to prevent accidental deployments.
- When selecting runners for pipelines, **prefer** using linux-based runners unless there is a specific requirement for doing otherwise.
- **ALWAYS** use specific versions of actions and tools in CI/CD pipelines to ensure consistency and reproducibility.
- Use caching in CI/CD pipelines where available and sensible to speed up builds and reduce resource consumption.
- Use template files for repeated or complex CI/CD tasks to improve maintainability and reduce duplication.
