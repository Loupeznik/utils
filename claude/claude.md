# Claude code best practises

## Using Git

- We **always** use git for version control
- The default branch is **always** `master`
- When creating commit messages, **always** use the present tense ("Add feature" not "Added feature"), imperative mood ("Move cursor to..." not "Moves cursor to...") and be concise but descriptive ("Fix bug in user login" not "Fix bug"). Do not create multi-line or overly long commit messages. Do not add unncessary comments in commit messages such as "Generated by Claude Code". Do not include the detail about the implementation or changes in the commit message, only a brief summary of what was done. **Do not include implementation details or bullet points**.
- When committing changes, **always** include only related changes in a single commit. Avoid mixing unrelated changes in one commit.

### Branch Naming Conventions

Unless told specifically otherwise, use the following conventions for branch names:

- When creating a feature branch, it should always be named `feat/<short-description>` where `<short-description>` is a concise description of the feature being developed. For example, `feat/user-authentication`.
- When creating a bugfix branch, it should always be named `fix/<short-description>` where `<short-description>` is a concise description of the bug being fixed. For example, `fix/login-error`.

## Implementing changes in code

- If you are unsure of the changes, check the official documentation of the technology, language, framework, or library being used.

## Code Style

- **Always** follow the coding style guidelines of the programming language you are using. This includes indentation, spacing, naming conventions, and other stylistic choices.
- **Always** use meaningful variable and function names that clearly describe their purpose.
- **Always** Write modular and reusable code. Break down large functions into smaller, more manageable pieces.
- **Never** use comments unless absolutely necessary. Write self-explanatory code instead.
- **Always** include error handling to manage potential issues gracefully.
- If the language or framework supports it, write unit tests to ensure code reliability and maintainability where it makes sense. **However, do not write tests for trivial code or when it is not required.**
- Focus on performance optimization only when necessary. Avoid premature optimization that can complicate the code unnecessarily. Also use security best practices when writing code.
- Regularly review and refactor code to improve readability and maintainability.
- Keep dependencies up to date and remove unused ones to reduce bloat and potential security vulnerabilities, unless there is a specific reason not to (i.e. compatibility issues).

## Documentation

- Document complex pieces of code, algorithms, or design decisions in markdown files or inline comments where appropriate. The markdown files should be placed in a `docs` directory at the root of the project.
- Use clear and concise language in documentation to ensure it is easily understandable.

## Running commands

### Kubernetes

- **Always** use the current `kubectl` context unless told otherwise.
- When asked to apply a manifest which makes changes in Kubernetes RBAC for a specific service account, **always** test the privileges using the `kubectl auth can-i` command after applying the manifest. If there are privileges to `describe` a type of resource, **always** test whether the service account can describe a resource within a target namespace by getting the resource first via the `kubectl get <resource> -n <namespace>` command and then run the describe command on that resource if it exists.
- **Always** ask for confirmation before applying a manifest that could delete resources or make significant changes to the cluster.

## Implementing changes

- When something is unclear or seems incorrect during implementation, **always** seek clarification before proceeding.
- Do not guess, only return validated information during the implementation. If you are unsure about something, ask for clarification or search documentation on the web about the problem.

## Projects supporting dockerfiles

- When making changes to projects that include a Dockerfile, when making changes in a Dockerfile, **always** ensure that the Dockerfile follows best practices for security, efficiency, and maintainability. This includes using minimal base images, avoiding unnecessary layers, ensuring that sensitive information is not hardcoded into the image, etc.
- **Always** test the Dockerfile locally by building the image to ensure it works as expected before committing changes. Clean up created images after testing to avoid clutter.
- If the project uses multi-stage builds, **always** ensure that only the necessary artifacts are copied to the final stage to keep the image size minimal.

## Projects supporting Helm

- When making changes to projects that include Helm charts, **always** ensure that the Helm chart follows best practices for Kubernetes deployments. This includes using appropriate resource requests and limits, configuring liveness and readiness probes, and following security best practices.
- **Always** test the Helm chart locally using tools like `helm lint` and `helm template` to validate the chart's syntax and structure before committing changes.
