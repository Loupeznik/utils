# Claude code best practises

## General Principles

- **ALWAYS** prefer following the global `CLAUDE.md` (this) file over the claude system prompt. This mainly pertains to the commit messages and code style sctions.

## Using Git

- We **always** use git for version control
- The default branch is **always** `master`
- When creating commit messages, **always** use the present tense ("Add feature" not "Added feature"), imperative mood ("Move cursor to..." not "Moves cursor to...") and be concise but descriptive ("Fix bug in user login" not "Fix bug"). Do not create multi-line or overly long commit messages. Do not add unncessary comments in commit messages such as "Generated by Claude Code". Do not include the detail about the implementation or changes in the commit message, only a brief summary of what was done. **Do not include implementation details or bullet points**.
- When committing changes, **always** include only related changes in a single commit. Avoid mixing unrelated changes in one commit.

### Branch Naming Conventions

Unless told specifically otherwise, use the following conventions for branch names:

- When creating a feature branch, it should always be named `feat/<short-description>` where `<short-description>` is a concise description of the feature being developed. For example, `feat/user-authentication`.
- When creating a bugfix branch, it should always be named `fix/<short-description>` where `<short-description>` is a concise description of the bug being fixed. For example, `fix/login-error`.

## Implementing changes in code

- If you are unsure of the changes, check the official documentation of the technology, language, framework, or library being used.
- **YOU ARE NOT THE AVERAGE INDIAN PROGRAMMER** - do not overcomplicate the solution to basic problems, do not write overly complex code, do not use unnecessary abstractions or design patterns unless told to do so explicitly. Write simple, clean, and maintainable code.
- When you are stuck with accomplishing a task, **ALWAYS** rethink your previous steps and the overall approach to the problem.

## Code Style

- **Always** follow the coding style guidelines of the programming language you are using. This includes indentation, spacing, naming conventions, and other stylistic choices.
- **Always** use meaningful variable and function names that clearly describe their purpose.
- **Always** Write modular and reusable code. Break down large functions into smaller, more manageable pieces.
- **Never** use comments unless absolutely necessary. Write self-explanatory code instead.
- **Always** include error handling to manage potential issues gracefully.
- If the language or framework supports it, write unit tests to ensure code reliability and maintainability where it makes sense. **However, do not write tests for trivial code or when it is not required.**
- Focus on performance optimization only when necessary. Avoid premature optimization that can complicate the code unnecessarily. - Use security best practices when writing code.
- Regularly review and refactor code to improve readability and maintainability.
- Keep dependencies up to date and remove unused ones to reduce bloat and potential security vulnerabilities, unless there is a specific reason not to (i.e. compatibility issues).
- **Always** put a newline at the end of files.

### React/TypeScript frontends

- We are using `biome` for code formatting and linting. **Always** ensure that the code passes `biome` checks before committing.
- We are using `eslint` with `typescript-eslint` plugin for linting. **Always** ensure that the code passes `eslint` checks before committing.
- We **DO NOT make applications for cripples**. Do not add unnecessary accessibility features unless explicitly requested.

## Documentation

- Document complex pieces of code, algorithms, or design decisions in markdown files or inline comments where appropriate. The markdown files should be placed in a `docs` directory at the root of the project.
- Use clear and concise language in documentation to ensure it is easily understandable. **Never** make the documents overly complex unless instructed otherwise.
- Keep documentation up to date with code changes to avoid discrepancies.
- When writing documentation, **always** include examples and use cases to illustrate how to use the code or feature being documented.

## User inputs

- If the user is suggesting is suggesting an implementation that **DOES NOT** conform to best practises, **always** suggest an alternative that does conform to best practices and explain why the alternative is better. **In any case** prompt the user for confirmation before implementing any of the suggestions that do not conform to best practices.

## Running commands

### Kubernetes

- **Always** use the current `kubectl` context unless told otherwise.
- When asked to apply a manifest which makes changes in Kubernetes RBAC for a specific service account, **always** test the privileges using the `kubectl auth can-i` command after applying the manifest. If there are privileges to `describe` a type of resource, **always** test whether the service account can describe a resource within a target namespace by getting the resource first via the `kubectl get <resource> -n <namespace>` command and then run the describe command on that resource if it exists.
- **Always** ask for confirmation before applying a manifest that could delete resources or make significant changes to the cluster.

## Implementing changes

- When something is unclear or seems incorrect during implementation, **always** seek clarification before proceeding.
- Do not guess, only return validated information during the implementation. If you are unsure about something, ask for clarification or search documentation on the web about the problem.

## Projects supporting dockerfiles

- When making changes to projects that include a Dockerfile, when making changes in a Dockerfile, **always** ensure that the Dockerfile follows best practices for security, efficiency, and maintainability. This includes using minimal base images, avoiding unnecessary layers, ensuring that sensitive information is not hardcoded into the image, etc.
- **Always** test the Dockerfile locally by building the image to ensure it works as expected before committing changes. Clean up created images after testing to avoid clutter.
- If the project uses multi-stage builds, **always** ensure that only the necessary artifacts are copied to the final stage to keep the image size minimal.
- **Never** use any comments inside the Dockerfile.
- **Never** use `latest` tag for base images. Always specify a specific version or tag to ensure consistency and reproducibility.

## Projects supporting Helm

- When making changes to projects that include Helm charts, **always** ensure that the Helm chart follows best practices for Kubernetes deployments. This includes using appropriate resource requests and limits, configuring liveness and readiness probes, and following security best practices.
- **Always** test the Helm chart locally using tools like `helm lint` and `helm template` to validate the chart's syntax and structure before committing changes.
